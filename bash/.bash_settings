#!/bin/bash

#
# environment variables
#

export EDITOR=vim

if type -p dotnet >/dev/null; then
    export DOTNET_CLI_TELEMETRY_OPTOUT=1
    export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=true
fi

#
# add paths to $PATH
#

if [[ :$PATH: != *:$HOME/bin:* ]]; then
    PATH=$PATH:$HOME/bin
fi

if [[ :$PATH: != *:$HOME/.local/bin:* ]]; then
    PATH=$PATH:$HOME/.local/bin
fi

case $(uname) in
    CYGWIN_NT*)
        if [ -d '/cygdrive/c/Program Files/Wireshark' ]; then
            PATH="$PATH:/cygdrive/c/Program Files/Wireshark"
        fi
        ;;
esac

#
# git prompt
#
#   dirty  unstaged *  staged +
#   stash $
#   untracked %
#   upstream  behind <  ahead >  diverged <>
#

if [ -f '/usr/share/git/git-prompt.sh' ]; then
    . '/usr/share/git/git-prompt.sh'
else
    __git_ps1() { : ; }
fi

GIT_PS1_SHOWDIRTYSTATE=1
GIT_PS1_SHOWSTASHSTATE=1
GIT_PS1_SHOWUNTRACKEDFILES=1
GIT_PS1_SHOWUPSTREAM="auto"

__exit_code() { [ $1 -ne 0 ] && echo -n "$1 " || true; }

PS1='$(__exit_code $?)[\u@\h \W$(__git_ps1 " (%s)")]\$ '

#
# start ssh-(p)age(a)nt
#

if [ -z "$SSH_AUTH_SOCK" ]; then
    if [ -n "$(type -p ssh-pageant.exe)" ]; then
        eval $(ssh-pageant)
        SSH_PAGEANT_KILL_ON_LOGOUT=1
    elif [ -n "$(type -p ssh-agent)" ]; then
        eval $(ssh-agent)
        export SSH_AGENT_KILL_ON_LOGOUT=$$
    fi
fi

# set the umask so that not everything gets created 755 / rwxr-xr-x --> thanks, Microsoft!
umask 0022

#
# load fzf completions and keybindings
#

#if [ -f '/usr/local/share/fzf/completion.bash' ]; then
#    echo 1
#    . '/usr/local/share/fzf/completion.bash'
#elif [ -f '/usr/share/fzf/completion.bash' ]; then
#    echo 2
#    . '/usr/share/fzf/completion.bash'
#fi

#if [ -f '/usr/local/share/fzf/key-bindings.bash' ]; then
#    echo 3
#    . '/usr/local/share/fzf/key-bindings.bash'
#elif [ -f '/usr/share/fzf/key-bindings.bash' ]; then
#    echo 4
#    . '/usr/share/fzf/key-bindings.bash'
#fi
